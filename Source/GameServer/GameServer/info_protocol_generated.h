// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INFOPROTOCOL_INFO_H_
#define FLATBUFFERS_GENERATED_INFOPROTOCOL_INFO_H_

#include "flatbuffers/flatbuffers.h"

#include "define_protocol_generated.h"

namespace Info {

struct Vec2Int;

struct PositionInfo;

struct Stat;

struct StatWrapper;
struct StatWrapperBuilder;
struct StatWrapperT;

struct Ability;

struct Speed;

struct CharacterGear;

struct Money;

struct MoneyWrapper;
struct MoneyWrapperBuilder;
struct MoneyWrapperT;

struct CreatureInfo;
struct CreatureInfoBuilder;
struct CreatureInfoT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2Int FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Vec2Int()
      : x_(0),
        y_(0) {
  }
  Vec2Int(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2Int, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PositionInfo FLATBUFFERS_FINAL_CLASS {
 private:
  Info::Vec2Int pos_;
  uint8_t state_;
  uint8_t move_dir_;
  int16_t padding0__;

 public:
  PositionInfo()
      : pos_(),
        state_(0),
        move_dir_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PositionInfo(const Info::Vec2Int &_pos, Define::CreatureState _state, Define::Dir _move_dir)
      : pos_(_pos),
        state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_state))),
        move_dir_(flatbuffers::EndianScalar(static_cast<uint8_t>(_move_dir))),
        padding0__(0) {
    (void)padding0__;
  }
  const Info::Vec2Int &pos() const {
    return pos_;
  }
  Define::CreatureState state() const {
    return static_cast<Define::CreatureState>(flatbuffers::EndianScalar(state_));
  }
  Define::Dir move_dir() const {
    return static_cast<Define::Dir>(flatbuffers::EndianScalar(move_dir_));
  }
};
FLATBUFFERS_STRUCT_END(PositionInfo, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Stat FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_[3];

 public:
  Stat()
      : value_() {
  }
  Stat(flatbuffers::span<const int32_t, 3> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<int32_t, 3> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Stat, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ability FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_[12];

 public:
  Ability()
      : value_() {
  }
  Ability(flatbuffers::span<const int32_t, 12> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<int32_t, 12> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Ability, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Speed FLATBUFFERS_FINAL_CLASS {
 private:
  float value_[3];

 public:
  Speed()
      : value_() {
  }
  Speed(flatbuffers::span<const float, 3> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<float, 3> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Speed, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(1) CharacterGear FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t index_[9];

 public:
  CharacterGear()
      : index_() {
  }
  CharacterGear(flatbuffers::span<const uint8_t, 9> _index) {
    flatbuffers::CastToArray(index_).CopyFromSpan(_index);
  }
  const flatbuffers::Array<uint8_t, 9> *index() const {
    return &flatbuffers::CastToArray(index_);
  }
};
FLATBUFFERS_STRUCT_END(CharacterGear, 9);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Money FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_[2];

 public:
  Money()
      : value_() {
  }
  Money(flatbuffers::span<const int32_t, 2> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<int32_t, 2> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Money, 8);

struct StatWrapperT : public flatbuffers::NativeTable {
  typedef StatWrapper TableType;
  NativeInfo::Stat value{};
};

struct StatWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatWrapperT NativeTableType;
  typedef StatWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Info::Stat *value() const {
    return GetStruct<const Info::Stat *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Info::Stat>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  StatWrapperT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatWrapperT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatWrapper> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatWrapperBuilder {
  typedef StatWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Info::Stat *value) {
    fbb_.AddStruct(StatWrapper::VT_VALUE, value);
  }
  explicit StatWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatWrapper> CreateStatWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Info::Stat *value = 0) {
  StatWrapperBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<StatWrapper> CreateStatWrapper(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoneyWrapperT : public flatbuffers::NativeTable {
  typedef MoneyWrapper TableType;
  NativeInfo::Money value{};
};

struct MoneyWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoneyWrapperT NativeTableType;
  typedef MoneyWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Info::Money *value() const {
    return GetStruct<const Info::Money *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Info::Money>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  MoneyWrapperT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoneyWrapperT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoneyWrapper> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoneyWrapperBuilder {
  typedef MoneyWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Info::Money *value) {
    fbb_.AddStruct(MoneyWrapper::VT_VALUE, value);
  }
  explicit MoneyWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MoneyWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoneyWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoneyWrapper> CreateMoneyWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Info::Money *value = 0) {
  MoneyWrapperBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<MoneyWrapper> CreateMoneyWrapper(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreatureInfoT : public flatbuffers::NativeTable {
  typedef CreatureInfo TableType;
  Define::ObjectType obj_type = Define::ObjectType_PLAYER;
  int64_t uid = 0;
  uint8_t level = 0;
  int64_t exp = 0;
  NativeInfo::Stat stat{};
  int32_t hp = 0;
  int32_t mp = 0;
  NativeInfo::Ability ability{};
  NativeInfo::Speed speed{};
  NativeInfo::PositionInfo pos_info{};
};

struct CreatureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatureInfoT NativeTableType;
  typedef CreatureInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJ_TYPE = 4,
    VT_UID = 6,
    VT_LEVEL = 8,
    VT_EXP = 10,
    VT_STAT = 12,
    VT_HP = 14,
    VT_MP = 16,
    VT_ABILITY = 18,
    VT_SPEED = 20,
    VT_POS_INFO = 22
  };
  Define::ObjectType obj_type() const {
    return static_cast<Define::ObjectType>(GetField<uint8_t>(VT_OBJ_TYPE, 0));
  }
  int64_t uid() const {
    return GetField<int64_t>(VT_UID, 0);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  int64_t exp() const {
    return GetField<int64_t>(VT_EXP, 0);
  }
  const Info::Stat *stat() const {
    return GetStruct<const Info::Stat *>(VT_STAT);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  const Info::Ability *ability() const {
    return GetStruct<const Info::Ability *>(VT_ABILITY);
  }
  const Info::Speed *speed() const {
    return GetStruct<const Info::Speed *>(VT_SPEED);
  }
  const Info::PositionInfo *pos_info() const {
    return GetStruct<const Info::PositionInfo *>(VT_POS_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_OBJ_TYPE) &&
           VerifyField<int64_t>(verifier, VT_UID) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_EXP) &&
           VerifyField<Info::Stat>(verifier, VT_STAT) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<Info::Ability>(verifier, VT_ABILITY) &&
           VerifyField<Info::Speed>(verifier, VT_SPEED) &&
           VerifyField<Info::PositionInfo>(verifier, VT_POS_INFO) &&
           verifier.EndTable();
  }
  CreatureInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreatureInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreatureInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreatureInfoBuilder {
  typedef CreatureInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_obj_type(Define::ObjectType obj_type) {
    fbb_.AddElement<uint8_t>(CreatureInfo::VT_OBJ_TYPE, static_cast<uint8_t>(obj_type), 0);
  }
  void add_uid(int64_t uid) {
    fbb_.AddElement<int64_t>(CreatureInfo::VT_UID, uid, 0);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(CreatureInfo::VT_LEVEL, level, 0);
  }
  void add_exp(int64_t exp) {
    fbb_.AddElement<int64_t>(CreatureInfo::VT_EXP, exp, 0);
  }
  void add_stat(const Info::Stat *stat) {
    fbb_.AddStruct(CreatureInfo::VT_STAT, stat);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(CreatureInfo::VT_HP, hp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(CreatureInfo::VT_MP, mp, 0);
  }
  void add_ability(const Info::Ability *ability) {
    fbb_.AddStruct(CreatureInfo::VT_ABILITY, ability);
  }
  void add_speed(const Info::Speed *speed) {
    fbb_.AddStruct(CreatureInfo::VT_SPEED, speed);
  }
  void add_pos_info(const Info::PositionInfo *pos_info) {
    fbb_.AddStruct(CreatureInfo::VT_POS_INFO, pos_info);
  }
  explicit CreatureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreatureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureInfo> CreateCreatureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    Define::ObjectType obj_type = Define::ObjectType_PLAYER,
    int64_t uid = 0,
    uint8_t level = 0,
    int64_t exp = 0,
    const Info::Stat *stat = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    const Info::Ability *ability = 0,
    const Info::Speed *speed = 0,
    const Info::PositionInfo *pos_info = 0) {
  CreatureInfoBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_uid(uid);
  builder_.add_pos_info(pos_info);
  builder_.add_speed(speed);
  builder_.add_ability(ability);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_stat(stat);
  builder_.add_level(level);
  builder_.add_obj_type(obj_type);
  return builder_.Finish();
}

flatbuffers::Offset<CreatureInfo> CreateCreatureInfo(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline StatWrapperT *StatWrapper::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StatWrapperT>(new StatWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StatWrapper::UnPackTo(StatWrapperT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = flatbuffers::UnPackStat(*_e); }
}

inline flatbuffers::Offset<StatWrapper> StatWrapper::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatWrapper(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatWrapper> CreateStatWrapper(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatWrapperT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = flatbuffers::PackStat(_o->value);
  return Info::CreateStatWrapper(
      _fbb,
      &_value);
}

inline MoneyWrapperT *MoneyWrapper::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoneyWrapperT>(new MoneyWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoneyWrapper::UnPackTo(MoneyWrapperT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = flatbuffers::UnPackMoney(*_e); }
}

inline flatbuffers::Offset<MoneyWrapper> MoneyWrapper::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoneyWrapper(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoneyWrapper> CreateMoneyWrapper(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoneyWrapperT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = flatbuffers::PackMoney(_o->value);
  return Info::CreateMoneyWrapper(
      _fbb,
      &_value);
}

inline CreatureInfoT *CreatureInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CreatureInfoT>(new CreatureInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CreatureInfo::UnPackTo(CreatureInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = obj_type(); _o->obj_type = _e; }
  { auto _e = uid(); _o->uid = _e; }
  { auto _e = level(); _o->level = _e; }
  { auto _e = exp(); _o->exp = _e; }
  { auto _e = stat(); if (_e) _o->stat = flatbuffers::UnPackStat(*_e); }
  { auto _e = hp(); _o->hp = _e; }
  { auto _e = mp(); _o->mp = _e; }
  { auto _e = ability(); if (_e) _o->ability = flatbuffers::UnPackAbility(*_e); }
  { auto _e = speed(); if (_e) _o->speed = flatbuffers::UnPackSpeed(*_e); }
  { auto _e = pos_info(); if (_e) _o->pos_info = flatbuffers::UnPackPositionInfo(*_e); }
}

inline flatbuffers::Offset<CreatureInfo> CreatureInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreatureInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreatureInfo> CreateCreatureInfo(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreatureInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _obj_type = _o->obj_type;
  auto _uid = _o->uid;
  auto _level = _o->level;
  auto _exp = _o->exp;
  auto _stat = flatbuffers::PackStat(_o->stat);
  auto _hp = _o->hp;
  auto _mp = _o->mp;
  auto _ability = flatbuffers::PackAbility(_o->ability);
  auto _speed = flatbuffers::PackSpeed(_o->speed);
  auto _pos_info = flatbuffers::PackPositionInfo(_o->pos_info);
  return Info::CreateCreatureInfo(
      _fbb,
      _obj_type,
      _uid,
      _level,
      _exp,
      &_stat,
      _hp,
      _mp,
      &_ability,
      &_speed,
      &_pos_info);
}

}  // namespace Info

#endif  // FLATBUFFERS_GENERATED_INFOPROTOCOL_INFO_H_
