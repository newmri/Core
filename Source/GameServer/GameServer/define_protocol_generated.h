// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEFINEPROTOCOL_DEFINE_H_
#define FLATBUFFERS_GENERATED_DEFINEPROTOCOL_DEFINE_H_

#include "flatbuffers/flatbuffers.h"

namespace Define {

enum ServerType : uint8_t {
  ServerType_WorldList = 0,
  ServerType_Login = 1,
  ServerType_Game = 2,
  ServerType_ServerTypeEnd = 3,
  ServerType_MIN = ServerType_WorldList,
  ServerType_MAX = ServerType_ServerTypeEnd
};

inline const ServerType (&EnumValuesServerType())[4] {
  static const ServerType values[] = {
    ServerType_WorldList,
    ServerType_Login,
    ServerType_Game,
    ServerType_ServerTypeEnd
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[5] = {
    "WorldList",
    "Login",
    "Game",
    "ServerTypeEnd",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (flatbuffers::IsOutRange(e, ServerType_WorldList, ServerType_ServerTypeEnd)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

enum Job : uint8_t {
  Job_WARRIOR = 0,
  Job_ARCHER = 1,
  Job_SORCERER = 2,
  Job_DUELIST = 3,
  Job_MIN = Job_WARRIOR,
  Job_MAX = Job_DUELIST
};

inline const Job (&EnumValuesJob())[4] {
  static const Job values[] = {
    Job_WARRIOR,
    Job_ARCHER,
    Job_SORCERER,
    Job_DUELIST
  };
  return values;
}

inline const char * const *EnumNamesJob() {
  static const char * const names[5] = {
    "WARRIOR",
    "ARCHER",
    "SORCERER",
    "DUELIST",
    nullptr
  };
  return names;
}

inline const char *EnumNameJob(Job e) {
  if (flatbuffers::IsOutRange(e, Job_WARRIOR, Job_DUELIST)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesJob()[index];
}

enum AccountLimit : uint8_t {
  AccountLimit_MinIDLen = 2,
  AccountLimit_MinPasswordLen = 4,
  AccountLimit_MaxIDLen = 10,
  AccountLimit_MaxPasswordLen = 15,
  AccountLimit_MIN = AccountLimit_MinIDLen,
  AccountLimit_MAX = AccountLimit_MaxPasswordLen
};

inline const AccountLimit (&EnumValuesAccountLimit())[4] {
  static const AccountLimit values[] = {
    AccountLimit_MinIDLen,
    AccountLimit_MinPasswordLen,
    AccountLimit_MaxIDLen,
    AccountLimit_MaxPasswordLen
  };
  return values;
}

inline const char * const *EnumNamesAccountLimit() {
  static const char * const names[15] = {
    "MinIDLen",
    "",
    "MinPasswordLen",
    "",
    "",
    "",
    "",
    "",
    "MaxIDLen",
    "",
    "",
    "",
    "",
    "MaxPasswordLen",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountLimit(AccountLimit e) {
  if (flatbuffers::IsOutRange(e, AccountLimit_MinIDLen, AccountLimit_MaxPasswordLen)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AccountLimit_MinIDLen);
  return EnumNamesAccountLimit()[index];
}

enum CharacterLimit : uint8_t {
  CharacterLimit_MinNameLen = 1,
  CharacterLimit_EmptyCharacterSlot = 3,
  CharacterLimit_MaxCharacterSlot = 5,
  CharacterLimit_MaxNameLen = 8,
  CharacterLimit_MIN = CharacterLimit_MinNameLen,
  CharacterLimit_MAX = CharacterLimit_MaxNameLen
};

inline const CharacterLimit (&EnumValuesCharacterLimit())[4] {
  static const CharacterLimit values[] = {
    CharacterLimit_MinNameLen,
    CharacterLimit_EmptyCharacterSlot,
    CharacterLimit_MaxCharacterSlot,
    CharacterLimit_MaxNameLen
  };
  return values;
}

inline const char * const *EnumNamesCharacterLimit() {
  static const char * const names[9] = {
    "MinNameLen",
    "",
    "EmptyCharacterSlot",
    "",
    "MaxCharacterSlot",
    "",
    "",
    "MaxNameLen",
    nullptr
  };
  return names;
}

inline const char *EnumNameCharacterLimit(CharacterLimit e) {
  if (flatbuffers::IsOutRange(e, CharacterLimit_MinNameLen, CharacterLimit_MaxNameLen)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CharacterLimit_MinNameLen);
  return EnumNamesCharacterLimit()[index];
}

enum StatType : uint8_t {
  StatType_STR = 0,
  StatType_DEX = 1,
  StatType_INT = 2,
  StatType_END = 3,
  StatType_MIN = StatType_STR,
  StatType_MAX = StatType_END
};

inline const StatType (&EnumValuesStatType())[4] {
  static const StatType values[] = {
    StatType_STR,
    StatType_DEX,
    StatType_INT,
    StatType_END
  };
  return values;
}

inline const char * const *EnumNamesStatType() {
  static const char * const names[5] = {
    "STR",
    "DEX",
    "INT",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatType(StatType e) {
  if (flatbuffers::IsOutRange(e, StatType_STR, StatType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatType()[index];
}

enum AbilityType : uint8_t {
  AbilityType_HP = 0,
  AbilityType_MP = 1,
  AbilityType_DAMAGE = 2,
  AbilityType_MAGIC_DAMAGE = 3,
  AbilityType_DEFENCE = 4,
  AbilityType_MAGIC_DEFENCE = 5,
  AbilityType_ATTACK_SPEED = 6,
  AbilityType_MAGIC_CASTING_SPEED = 7,
  AbilityType_MOVE_SPEED = 8,
  AbilityType_CRITICAL_RATE = 9,
  AbilityType_MAGIC_CRITICAL_RATE = 10,
  AbilityType_LIGHT_REGISTTANCE = 11,
  AbilityType_DARK_REGISTTANCE = 12,
  AbilityType_FIRE_REGISTTANCE = 13,
  AbilityType_ICE_REGISTTANCE = 14,
  AbilityType_END = 15,
  AbilityType_MIN = AbilityType_HP,
  AbilityType_MAX = AbilityType_END
};

inline const AbilityType (&EnumValuesAbilityType())[16] {
  static const AbilityType values[] = {
    AbilityType_HP,
    AbilityType_MP,
    AbilityType_DAMAGE,
    AbilityType_MAGIC_DAMAGE,
    AbilityType_DEFENCE,
    AbilityType_MAGIC_DEFENCE,
    AbilityType_ATTACK_SPEED,
    AbilityType_MAGIC_CASTING_SPEED,
    AbilityType_MOVE_SPEED,
    AbilityType_CRITICAL_RATE,
    AbilityType_MAGIC_CRITICAL_RATE,
    AbilityType_LIGHT_REGISTTANCE,
    AbilityType_DARK_REGISTTANCE,
    AbilityType_FIRE_REGISTTANCE,
    AbilityType_ICE_REGISTTANCE,
    AbilityType_END
  };
  return values;
}

inline const char * const *EnumNamesAbilityType() {
  static const char * const names[17] = {
    "HP",
    "MP",
    "DAMAGE",
    "MAGIC_DAMAGE",
    "DEFENCE",
    "MAGIC_DEFENCE",
    "ATTACK_SPEED",
    "MAGIC_CASTING_SPEED",
    "MOVE_SPEED",
    "CRITICAL_RATE",
    "MAGIC_CRITICAL_RATE",
    "LIGHT_REGISTTANCE",
    "DARK_REGISTTANCE",
    "FIRE_REGISTTANCE",
    "ICE_REGISTTANCE",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityType(AbilityType e) {
  if (flatbuffers::IsOutRange(e, AbilityType_HP, AbilityType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAbilityType()[index];
}

enum AbilityByStatType : uint8_t {
  AbilityByStatType_HP = 0,
  AbilityByStatType_MP = 1,
  AbilityByStatType_DAMAGE = 2,
  AbilityByStatType_MAGIC_DAMAGE = 3,
  AbilityByStatType_DEFENCE = 4,
  AbilityByStatType_MAGIC_DEFENCE = 5,
  AbilityByStatType_END = 6,
  AbilityByStatType_MIN = AbilityByStatType_HP,
  AbilityByStatType_MAX = AbilityByStatType_END
};

inline const AbilityByStatType (&EnumValuesAbilityByStatType())[7] {
  static const AbilityByStatType values[] = {
    AbilityByStatType_HP,
    AbilityByStatType_MP,
    AbilityByStatType_DAMAGE,
    AbilityByStatType_MAGIC_DAMAGE,
    AbilityByStatType_DEFENCE,
    AbilityByStatType_MAGIC_DEFENCE,
    AbilityByStatType_END
  };
  return values;
}

inline const char * const *EnumNamesAbilityByStatType() {
  static const char * const names[8] = {
    "HP",
    "MP",
    "DAMAGE",
    "MAGIC_DAMAGE",
    "DEFENCE",
    "MAGIC_DEFENCE",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityByStatType(AbilityByStatType e) {
  if (flatbuffers::IsOutRange(e, AbilityByStatType_HP, AbilityByStatType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAbilityByStatType()[index];
}

enum GearType : uint8_t {
  GearType_LEFT_HAND = 0,
  GearType_RIGHT_HAND = 1,
  GearType_ARMOR = 2,
  GearType_HELMET = 3,
  GearType_SHOULDER = 4,
  GearType_ARM = 5,
  GearType_FEET = 6,
  GearType_HAIR = 7,
  GearType_FACE = 8,
  GearType_END = 9,
  GearType_MIN = GearType_LEFT_HAND,
  GearType_MAX = GearType_END
};

inline const GearType (&EnumValuesGearType())[10] {
  static const GearType values[] = {
    GearType_LEFT_HAND,
    GearType_RIGHT_HAND,
    GearType_ARMOR,
    GearType_HELMET,
    GearType_SHOULDER,
    GearType_ARM,
    GearType_FEET,
    GearType_HAIR,
    GearType_FACE,
    GearType_END
  };
  return values;
}

inline const char * const *EnumNamesGearType() {
  static const char * const names[11] = {
    "LEFT_HAND",
    "RIGHT_HAND",
    "ARMOR",
    "HELMET",
    "SHOULDER",
    "ARM",
    "FEET",
    "HAIR",
    "FACE",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameGearType(GearType e) {
  if (flatbuffers::IsOutRange(e, GearType_LEFT_HAND, GearType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesGearType()[index];
}

enum Dir : uint8_t {
  Dir_UP = 0,
  Dir_DOWN = 1,
  Dir_LEFT = 2,
  Dir_RIGHT = 3,
  Dir_MIN = Dir_UP,
  Dir_MAX = Dir_RIGHT
};

inline const Dir (&EnumValuesDir())[4] {
  static const Dir values[] = {
    Dir_UP,
    Dir_DOWN,
    Dir_LEFT,
    Dir_RIGHT
  };
  return values;
}

inline const char * const *EnumNamesDir() {
  static const char * const names[5] = {
    "UP",
    "DOWN",
    "LEFT",
    "RIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameDir(Dir e) {
  if (flatbuffers::IsOutRange(e, Dir_UP, Dir_RIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDir()[index];
}

enum CreatureState : uint8_t {
  CreatureState_IDLE = 0,
  CreatureState_WALK = 1,
  CreatureState_RUN = 2,
  CreatureState_JUMP = 3,
  CreatureState_SKILL = 4,
  CreatureState_DEAD = 5,
  CreatureState_MIN = CreatureState_IDLE,
  CreatureState_MAX = CreatureState_DEAD
};

inline const CreatureState (&EnumValuesCreatureState())[6] {
  static const CreatureState values[] = {
    CreatureState_IDLE,
    CreatureState_WALK,
    CreatureState_RUN,
    CreatureState_JUMP,
    CreatureState_SKILL,
    CreatureState_DEAD
  };
  return values;
}

inline const char * const *EnumNamesCreatureState() {
  static const char * const names[7] = {
    "IDLE",
    "WALK",
    "RUN",
    "JUMP",
    "SKILL",
    "DEAD",
    nullptr
  };
  return names;
}

inline const char *EnumNameCreatureState(CreatureState e) {
  if (flatbuffers::IsOutRange(e, CreatureState_IDLE, CreatureState_DEAD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesCreatureState()[index];
}

enum Money : uint8_t {
  Money_GEM = 0,
  Money_GOLD = 1,
  Money_MONEY_END = 2,
  Money_MIN = Money_GEM,
  Money_MAX = Money_MONEY_END
};

inline const Money (&EnumValuesMoney())[3] {
  static const Money values[] = {
    Money_GEM,
    Money_GOLD,
    Money_MONEY_END
  };
  return values;
}

inline const char * const *EnumNamesMoney() {
  static const char * const names[4] = {
    "GEM",
    "GOLD",
    "MONEY_END",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoney(Money e) {
  if (flatbuffers::IsOutRange(e, Money_GEM, Money_MONEY_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMoney()[index];
}

}  // namespace Define

#endif  // FLATBUFFERS_GENERATED_DEFINEPROTOCOL_DEFINE_H_
