// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_DEFINEPROTOCOL_DEFINE_H_
#define FLATBUFFERS_GENERATED_DEFINEPROTOCOL_DEFINE_H_

#include "flatbuffers/flatbuffers.h"

namespace Define {

enum ServerType : uint8_t {
  ServerType_WorldList = 0,
  ServerType_Login = 1,
  ServerType_Game = 2,
  ServerType_ServerTypeEnd = 3,
  ServerType_MIN = ServerType_WorldList,
  ServerType_MAX = ServerType_ServerTypeEnd
};

inline const ServerType (&EnumValuesServerType())[4] {
  static const ServerType values[] = {
    ServerType_WorldList,
    ServerType_Login,
    ServerType_Game,
    ServerType_ServerTypeEnd
  };
  return values;
}

inline const char * const *EnumNamesServerType() {
  static const char * const names[5] = {
    "WorldList",
    "Login",
    "Game",
    "ServerTypeEnd",
    nullptr
  };
  return names;
}

inline const char *EnumNameServerType(ServerType e) {
  if (flatbuffers::IsOutRange(e, ServerType_WorldList, ServerType_ServerTypeEnd)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesServerType()[index];
}

enum Job : uint8_t {
  Job_WARRIOR = 0,
  Job_ARCHER = 1,
  Job_SORCERER = 2,
  Job_DUELIST = 3,
  Job_NONE = 255,
  Job_MIN = Job_WARRIOR,
  Job_MAX = Job_NONE
};

inline const Job (&EnumValuesJob())[5] {
  static const Job values[] = {
    Job_WARRIOR,
    Job_ARCHER,
    Job_SORCERER,
    Job_DUELIST,
    Job_NONE
  };
  return values;
}

inline const char *EnumNameJob(Job e) {
  switch (e) {
    case Job_WARRIOR: return "WARRIOR";
    case Job_ARCHER: return "ARCHER";
    case Job_SORCERER: return "SORCERER";
    case Job_DUELIST: return "DUELIST";
    case Job_NONE: return "NONE";
    default: return "";
  }
}

enum AccountLimit : uint8_t {
  AccountLimit_MinIDLen = 2,
  AccountLimit_MinPasswordLen = 4,
  AccountLimit_MaxIDLen = 10,
  AccountLimit_MaxPasswordLen = 15,
  AccountLimit_MIN = AccountLimit_MinIDLen,
  AccountLimit_MAX = AccountLimit_MaxPasswordLen
};

inline const AccountLimit (&EnumValuesAccountLimit())[4] {
  static const AccountLimit values[] = {
    AccountLimit_MinIDLen,
    AccountLimit_MinPasswordLen,
    AccountLimit_MaxIDLen,
    AccountLimit_MaxPasswordLen
  };
  return values;
}

inline const char * const *EnumNamesAccountLimit() {
  static const char * const names[15] = {
    "MinIDLen",
    "",
    "MinPasswordLen",
    "",
    "",
    "",
    "",
    "",
    "MaxIDLen",
    "",
    "",
    "",
    "",
    "MaxPasswordLen",
    nullptr
  };
  return names;
}

inline const char *EnumNameAccountLimit(AccountLimit e) {
  if (flatbuffers::IsOutRange(e, AccountLimit_MinIDLen, AccountLimit_MaxPasswordLen)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AccountLimit_MinIDLen);
  return EnumNamesAccountLimit()[index];
}

enum CharacterLimit : uint8_t {
  CharacterLimit_MinNameLen = 1,
  CharacterLimit_EmptyCharacterSlot = 3,
  CharacterLimit_MaxCharacterSlot = 5,
  CharacterLimit_MaxNameLen = 8,
  CharacterLimit_MIN = CharacterLimit_MinNameLen,
  CharacterLimit_MAX = CharacterLimit_MaxNameLen
};

inline const CharacterLimit (&EnumValuesCharacterLimit())[4] {
  static const CharacterLimit values[] = {
    CharacterLimit_MinNameLen,
    CharacterLimit_EmptyCharacterSlot,
    CharacterLimit_MaxCharacterSlot,
    CharacterLimit_MaxNameLen
  };
  return values;
}

inline const char * const *EnumNamesCharacterLimit() {
  static const char * const names[9] = {
    "MinNameLen",
    "",
    "EmptyCharacterSlot",
    "",
    "MaxCharacterSlot",
    "",
    "",
    "MaxNameLen",
    nullptr
  };
  return names;
}

inline const char *EnumNameCharacterLimit(CharacterLimit e) {
  if (flatbuffers::IsOutRange(e, CharacterLimit_MinNameLen, CharacterLimit_MaxNameLen)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(CharacterLimit_MinNameLen);
  return EnumNamesCharacterLimit()[index];
}

enum StatType : uint8_t {
  StatType_STR = 0,
  StatType_DEX = 1,
  StatType_INT = 2,
  StatType_END = 3,
  StatType_MIN = StatType_STR,
  StatType_MAX = StatType_END
};

inline const StatType (&EnumValuesStatType())[4] {
  static const StatType values[] = {
    StatType_STR,
    StatType_DEX,
    StatType_INT,
    StatType_END
  };
  return values;
}

inline const char * const *EnumNamesStatType() {
  static const char * const names[5] = {
    "STR",
    "DEX",
    "INT",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameStatType(StatType e) {
  if (flatbuffers::IsOutRange(e, StatType_STR, StatType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesStatType()[index];
}

enum AbilityType : uint8_t {
  AbilityType_HP = 0,
  AbilityType_MP = 1,
  AbilityType_DAMAGE = 2,
  AbilityType_MAGIC_DAMAGE = 3,
  AbilityType_DEFENCE = 4,
  AbilityType_MAGIC_DEFENCE = 5,
  AbilityType_CRITICAL_RATE = 6,
  AbilityType_MAGIC_CRITICAL_RATE = 7,
  AbilityType_LIGHT_REGISTANCE_RATE = 8,
  AbilityType_DARK_REGISTANCE_RATE = 9,
  AbilityType_FIRE_REGISTANCE_RATE = 10,
  AbilityType_WATER_REGISTANCE_RATE = 11,
  AbilityType_END = 12,
  AbilityType_MIN = AbilityType_HP,
  AbilityType_MAX = AbilityType_END
};

inline const AbilityType (&EnumValuesAbilityType())[13] {
  static const AbilityType values[] = {
    AbilityType_HP,
    AbilityType_MP,
    AbilityType_DAMAGE,
    AbilityType_MAGIC_DAMAGE,
    AbilityType_DEFENCE,
    AbilityType_MAGIC_DEFENCE,
    AbilityType_CRITICAL_RATE,
    AbilityType_MAGIC_CRITICAL_RATE,
    AbilityType_LIGHT_REGISTANCE_RATE,
    AbilityType_DARK_REGISTANCE_RATE,
    AbilityType_FIRE_REGISTANCE_RATE,
    AbilityType_WATER_REGISTANCE_RATE,
    AbilityType_END
  };
  return values;
}

inline const char * const *EnumNamesAbilityType() {
  static const char * const names[14] = {
    "HP",
    "MP",
    "DAMAGE",
    "MAGIC_DAMAGE",
    "DEFENCE",
    "MAGIC_DEFENCE",
    "CRITICAL_RATE",
    "MAGIC_CRITICAL_RATE",
    "LIGHT_REGISTANCE_RATE",
    "DARK_REGISTANCE_RATE",
    "FIRE_REGISTANCE_RATE",
    "WATER_REGISTANCE_RATE",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityType(AbilityType e) {
  if (flatbuffers::IsOutRange(e, AbilityType_HP, AbilityType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAbilityType()[index];
}

enum AbilityRate : uint16_t {
  AbilityRate_RATE = 10000,
  AbilityRate_MIN = AbilityRate_RATE,
  AbilityRate_MAX = AbilityRate_RATE
};

inline const AbilityRate (&EnumValuesAbilityRate())[1] {
  static const AbilityRate values[] = {
    AbilityRate_RATE
  };
  return values;
}

inline const char * const *EnumNamesAbilityRate() {
  static const char * const names[2] = {
    "RATE",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityRate(AbilityRate e) {
  if (flatbuffers::IsOutRange(e, AbilityRate_RATE, AbilityRate_RATE)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(AbilityRate_RATE);
  return EnumNamesAbilityRate()[index];
}

enum SpeedType : uint8_t {
  SpeedType_ATTACK_SPEED = 0,
  SpeedType_MAGIC_CASTING_SPEED = 1,
  SpeedType_MOVE_SPEED = 2,
  SpeedType_END = 3,
  SpeedType_MIN = SpeedType_ATTACK_SPEED,
  SpeedType_MAX = SpeedType_END
};

inline const SpeedType (&EnumValuesSpeedType())[4] {
  static const SpeedType values[] = {
    SpeedType_ATTACK_SPEED,
    SpeedType_MAGIC_CASTING_SPEED,
    SpeedType_MOVE_SPEED,
    SpeedType_END
  };
  return values;
}

inline const char * const *EnumNamesSpeedType() {
  static const char * const names[5] = {
    "ATTACK_SPEED",
    "MAGIC_CASTING_SPEED",
    "MOVE_SPEED",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameSpeedType(SpeedType e) {
  if (flatbuffers::IsOutRange(e, SpeedType_ATTACK_SPEED, SpeedType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSpeedType()[index];
}

enum AbilityByStatType : uint8_t {
  AbilityByStatType_HP = 0,
  AbilityByStatType_MP = 1,
  AbilityByStatType_DAMAGE = 2,
  AbilityByStatType_MAGIC_DAMAGE = 3,
  AbilityByStatType_DEFENCE = 4,
  AbilityByStatType_MAGIC_DEFENCE = 5,
  AbilityByStatType_END = 6,
  AbilityByStatType_MIN = AbilityByStatType_HP,
  AbilityByStatType_MAX = AbilityByStatType_END
};

inline const AbilityByStatType (&EnumValuesAbilityByStatType())[7] {
  static const AbilityByStatType values[] = {
    AbilityByStatType_HP,
    AbilityByStatType_MP,
    AbilityByStatType_DAMAGE,
    AbilityByStatType_MAGIC_DAMAGE,
    AbilityByStatType_DEFENCE,
    AbilityByStatType_MAGIC_DEFENCE,
    AbilityByStatType_END
  };
  return values;
}

inline const char * const *EnumNamesAbilityByStatType() {
  static const char * const names[8] = {
    "HP",
    "MP",
    "DAMAGE",
    "MAGIC_DAMAGE",
    "DEFENCE",
    "MAGIC_DEFENCE",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameAbilityByStatType(AbilityByStatType e) {
  if (flatbuffers::IsOutRange(e, AbilityByStatType_HP, AbilityByStatType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesAbilityByStatType()[index];
}

enum GearType : uint8_t {
  GearType_LEFT_HAND = 0,
  GearType_RIGHT_HAND = 1,
  GearType_ARMOR = 2,
  GearType_HELMET = 3,
  GearType_SHOULDER = 4,
  GearType_ARM = 5,
  GearType_FEET = 6,
  GearType_HAIR = 7,
  GearType_EYES = 8,
  GearType_END = 9,
  GearType_NONE = 255,
  GearType_MIN = GearType_LEFT_HAND,
  GearType_MAX = GearType_NONE
};

inline const GearType (&EnumValuesGearType())[11] {
  static const GearType values[] = {
    GearType_LEFT_HAND,
    GearType_RIGHT_HAND,
    GearType_ARMOR,
    GearType_HELMET,
    GearType_SHOULDER,
    GearType_ARM,
    GearType_FEET,
    GearType_HAIR,
    GearType_EYES,
    GearType_END,
    GearType_NONE
  };
  return values;
}

inline const char *EnumNameGearType(GearType e) {
  switch (e) {
    case GearType_LEFT_HAND: return "LEFT_HAND";
    case GearType_RIGHT_HAND: return "RIGHT_HAND";
    case GearType_ARMOR: return "ARMOR";
    case GearType_HELMET: return "HELMET";
    case GearType_SHOULDER: return "SHOULDER";
    case GearType_ARM: return "ARM";
    case GearType_FEET: return "FEET";
    case GearType_HAIR: return "HAIR";
    case GearType_EYES: return "EYES";
    case GearType_END: return "END";
    case GearType_NONE: return "NONE";
    default: return "";
  }
}

enum Dir : uint8_t {
  Dir_UP = 0,
  Dir_DOWN = 1,
  Dir_LEFT = 2,
  Dir_RIGHT = 3,
  Dir_MIN = Dir_UP,
  Dir_MAX = Dir_RIGHT
};

inline const Dir (&EnumValuesDir())[4] {
  static const Dir values[] = {
    Dir_UP,
    Dir_DOWN,
    Dir_LEFT,
    Dir_RIGHT
  };
  return values;
}

inline const char * const *EnumNamesDir() {
  static const char * const names[5] = {
    "UP",
    "DOWN",
    "LEFT",
    "RIGHT",
    nullptr
  };
  return names;
}

inline const char *EnumNameDir(Dir e) {
  if (flatbuffers::IsOutRange(e, Dir_UP, Dir_RIGHT)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesDir()[index];
}

enum RangeDir : uint8_t {
  RangeDir_FRONT = 0,
  RangeDir_BACK = 1,
  RangeDir_TWO_WAY = 2,
  RangeDir_UP = 3,
  RangeDir_DOWN = 4,
  RangeDir_ALL = 5,
  RangeDir_MIN = RangeDir_FRONT,
  RangeDir_MAX = RangeDir_ALL
};

inline const RangeDir (&EnumValuesRangeDir())[6] {
  static const RangeDir values[] = {
    RangeDir_FRONT,
    RangeDir_BACK,
    RangeDir_TWO_WAY,
    RangeDir_UP,
    RangeDir_DOWN,
    RangeDir_ALL
  };
  return values;
}

inline const char * const *EnumNamesRangeDir() {
  static const char * const names[7] = {
    "FRONT",
    "BACK",
    "TWO_WAY",
    "UP",
    "DOWN",
    "ALL",
    nullptr
  };
  return names;
}

inline const char *EnumNameRangeDir(RangeDir e) {
  if (flatbuffers::IsOutRange(e, RangeDir_FRONT, RangeDir_ALL)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesRangeDir()[index];
}

enum ObjectState : uint8_t {
  ObjectState_IDLE = 0,
  ObjectState_WALK = 1,
  ObjectState_RUN = 2,
  ObjectState_JUMP = 3,
  ObjectState_HIT = 4,
  ObjectState_SKILL = 5,
  ObjectState_DEAD = 6,
  ObjectState_MIN = ObjectState_IDLE,
  ObjectState_MAX = ObjectState_DEAD
};

inline const ObjectState (&EnumValuesObjectState())[7] {
  static const ObjectState values[] = {
    ObjectState_IDLE,
    ObjectState_WALK,
    ObjectState_RUN,
    ObjectState_JUMP,
    ObjectState_HIT,
    ObjectState_SKILL,
    ObjectState_DEAD
  };
  return values;
}

inline const char * const *EnumNamesObjectState() {
  static const char * const names[8] = {
    "IDLE",
    "WALK",
    "RUN",
    "JUMP",
    "HIT",
    "SKILL",
    "DEAD",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectState(ObjectState e) {
  if (flatbuffers::IsOutRange(e, ObjectState_IDLE, ObjectState_DEAD)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectState()[index];
}

enum MoneyType : uint8_t {
  MoneyType_GEM = 0,
  MoneyType_GOLD = 1,
  MoneyType_END = 2,
  MoneyType_MIN = MoneyType_GEM,
  MoneyType_MAX = MoneyType_END
};

inline const MoneyType (&EnumValuesMoneyType())[3] {
  static const MoneyType values[] = {
    MoneyType_GEM,
    MoneyType_GOLD,
    MoneyType_END
  };
  return values;
}

inline const char * const *EnumNamesMoneyType() {
  static const char * const names[4] = {
    "GEM",
    "GOLD",
    "END",
    nullptr
  };
  return names;
}

inline const char *EnumNameMoneyType(MoneyType e) {
  if (flatbuffers::IsOutRange(e, MoneyType_GEM, MoneyType_END)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesMoneyType()[index];
}

enum ObjectType : uint8_t {
  ObjectType_NONE = 0,
  ObjectType_PLAYER = 1,
  ObjectType_PROJECTILE = 2,
  ObjectType_MONSTER = 3,
  ObjectType_NPC = 4,
  ObjectType_MIN = ObjectType_NONE,
  ObjectType_MAX = ObjectType_NPC
};

inline const ObjectType (&EnumValuesObjectType())[5] {
  static const ObjectType values[] = {
    ObjectType_NONE,
    ObjectType_PLAYER,
    ObjectType_PROJECTILE,
    ObjectType_MONSTER,
    ObjectType_NPC
  };
  return values;
}

inline const char * const *EnumNamesObjectType() {
  static const char * const names[6] = {
    "NONE",
    "PLAYER",
    "PROJECTILE",
    "MONSTER",
    "NPC",
    nullptr
  };
  return names;
}

inline const char *EnumNameObjectType(ObjectType e) {
  if (flatbuffers::IsOutRange(e, ObjectType_NONE, ObjectType_NPC)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesObjectType()[index];
}

enum ProjectileType : uint8_t {
  ProjectileType_NONE = 0,
  ProjectileType_ARROW = 1,
  ProjectileType_MAGIC_ARROW = 2,
  ProjectileType_MIN = ProjectileType_NONE,
  ProjectileType_MAX = ProjectileType_MAGIC_ARROW
};

inline const ProjectileType (&EnumValuesProjectileType())[3] {
  static const ProjectileType values[] = {
    ProjectileType_NONE,
    ProjectileType_ARROW,
    ProjectileType_MAGIC_ARROW
  };
  return values;
}

inline const char * const *EnumNamesProjectileType() {
  static const char * const names[4] = {
    "NONE",
    "ARROW",
    "MAGIC_ARROW",
    nullptr
  };
  return names;
}

inline const char *EnumNameProjectileType(ProjectileType e) {
  if (flatbuffers::IsOutRange(e, ProjectileType_NONE, ProjectileType_MAGIC_ARROW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesProjectileType()[index];
}

enum PathType : uint8_t {
  PathType_NONE = 0,
  PathType_START = 1,
  PathType_COLLISION = 2,
  PathType_PATH = 3,
  PathType_MIN = PathType_NONE,
  PathType_MAX = PathType_PATH
};

inline const PathType (&EnumValuesPathType())[4] {
  static const PathType values[] = {
    PathType_NONE,
    PathType_START,
    PathType_COLLISION,
    PathType_PATH
  };
  return values;
}

inline const char * const *EnumNamesPathType() {
  static const char * const names[5] = {
    "NONE",
    "START",
    "COLLISION",
    "PATH",
    nullptr
  };
  return names;
}

inline const char *EnumNamePathType(PathType e) {
  if (flatbuffers::IsOutRange(e, PathType_NONE, PathType_PATH)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPathType()[index];
}

enum SkillType : uint8_t {
  SkillType_NONE = 0,
  SkillType_NORMAL = 1,
  SkillType_ARROW = 2,
  SkillType_MIN = SkillType_NONE,
  SkillType_MAX = SkillType_ARROW
};

inline const SkillType (&EnumValuesSkillType())[3] {
  static const SkillType values[] = {
    SkillType_NONE,
    SkillType_NORMAL,
    SkillType_ARROW
  };
  return values;
}

inline const char * const *EnumNamesSkillType() {
  static const char * const names[4] = {
    "NONE",
    "NORMAL",
    "ARROW",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillType(SkillType e) {
  if (flatbuffers::IsOutRange(e, SkillType_NONE, SkillType_ARROW)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillType()[index];
}

enum SkillAnimationType : uint8_t {
  SkillAnimationType_NONE = 0,
  SkillAnimationType_ATTACK_1 = 1,
  SkillAnimationType_ATTACK_2 = 2,
  SkillAnimationType_MIN = SkillAnimationType_NONE,
  SkillAnimationType_MAX = SkillAnimationType_ATTACK_2
};

inline const SkillAnimationType (&EnumValuesSkillAnimationType())[3] {
  static const SkillAnimationType values[] = {
    SkillAnimationType_NONE,
    SkillAnimationType_ATTACK_1,
    SkillAnimationType_ATTACK_2
  };
  return values;
}

inline const char * const *EnumNamesSkillAnimationType() {
  static const char * const names[4] = {
    "NONE",
    "ATTACK_1",
    "ATTACK_2",
    nullptr
  };
  return names;
}

inline const char *EnumNameSkillAnimationType(SkillAnimationType e) {
  if (flatbuffers::IsOutRange(e, SkillAnimationType_NONE, SkillAnimationType_ATTACK_2)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesSkillAnimationType()[index];
}

enum ReviveTime : int32_t {
  ReviveTime_COOL_TIME = 5,
  ReviveTime_MIN = ReviveTime_COOL_TIME,
  ReviveTime_MAX = ReviveTime_COOL_TIME
};

inline const ReviveTime (&EnumValuesReviveTime())[1] {
  static const ReviveTime values[] = {
    ReviveTime_COOL_TIME
  };
  return values;
}

inline const char * const *EnumNamesReviveTime() {
  static const char * const names[2] = {
    "COOL_TIME",
    nullptr
  };
  return names;
}

inline const char *EnumNameReviveTime(ReviveTime e) {
  if (flatbuffers::IsOutRange(e, ReviveTime_COOL_TIME, ReviveTime_COOL_TIME)) return "";
  const size_t index = static_cast<size_t>(e) - static_cast<size_t>(ReviveTime_COOL_TIME);
  return EnumNamesReviveTime()[index];
}

}  // namespace Define

#endif  // FLATBUFFERS_GENERATED_DEFINEPROTOCOL_DEFINE_H_
