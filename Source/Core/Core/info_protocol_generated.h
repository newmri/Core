// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_INFOPROTOCOL_INFO_H_
#define FLATBUFFERS_GENERATED_INFOPROTOCOL_INFO_H_

#include "flatbuffers/flatbuffers.h"

#include "define_protocol_generated.h"

namespace Info {

struct Vec2Int;

struct ObjectInfo;

struct PositionInfo;

struct ObjectInfoWithPos;
struct ObjectInfoWithPosBuilder;
struct ObjectInfoWithPosT;

struct Stat;

struct StatWrapper;
struct StatWrapperBuilder;
struct StatWrapperT;

struct Ability;

struct Speed;

struct CharacterGear;

struct Money;

struct MoneyWrapper;
struct MoneyWrapperBuilder;
struct MoneyWrapperT;

struct CreatureInfo;
struct CreatureInfoBuilder;
struct CreatureInfoT;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Vec2Int FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t x_;
  int32_t y_;

 public:
  Vec2Int()
      : x_(0),
        y_(0) {
  }
  Vec2Int(int32_t _x, int32_t _y)
      : x_(flatbuffers::EndianScalar(_x)),
        y_(flatbuffers::EndianScalar(_y)) {
  }
  int32_t x() const {
    return flatbuffers::EndianScalar(x_);
  }
  int32_t y() const {
    return flatbuffers::EndianScalar(y_);
  }
};
FLATBUFFERS_STRUCT_END(Vec2Int, 8);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) ObjectInfo FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t object_type_;
  int8_t padding0__;  int16_t padding1__;  int32_t padding2__;
  int64_t oid_;

 public:
  ObjectInfo()
      : object_type_(0),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        oid_(0) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  ObjectInfo(Define::ObjectType _object_type, int64_t _oid)
      : object_type_(flatbuffers::EndianScalar(static_cast<uint8_t>(_object_type))),
        padding0__(0),
        padding1__(0),
        padding2__(0),
        oid_(flatbuffers::EndianScalar(_oid)) {
    (void)padding0__;
    (void)padding1__;
    (void)padding2__;
  }
  Define::ObjectType object_type() const {
    return static_cast<Define::ObjectType>(flatbuffers::EndianScalar(object_type_));
  }
  int64_t oid() const {
    return flatbuffers::EndianScalar(oid_);
  }
};
FLATBUFFERS_STRUCT_END(ObjectInfo, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) PositionInfo FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t map_id_;
  Info::Vec2Int pos_;
  uint8_t state_;
  uint8_t move_dir_;
  int16_t padding0__;

 public:
  PositionInfo()
      : map_id_(0),
        pos_(),
        state_(0),
        move_dir_(0),
        padding0__(0) {
    (void)padding0__;
  }
  PositionInfo(int32_t _map_id, const Info::Vec2Int &_pos, Define::ObjectState _state, Define::Dir _move_dir)
      : map_id_(flatbuffers::EndianScalar(_map_id)),
        pos_(_pos),
        state_(flatbuffers::EndianScalar(static_cast<uint8_t>(_state))),
        move_dir_(flatbuffers::EndianScalar(static_cast<uint8_t>(_move_dir))),
        padding0__(0) {
    (void)padding0__;
  }
  int32_t map_id() const {
    return flatbuffers::EndianScalar(map_id_);
  }
  const Info::Vec2Int &pos() const {
    return pos_;
  }
  Define::ObjectState state() const {
    return static_cast<Define::ObjectState>(flatbuffers::EndianScalar(state_));
  }
  Define::Dir move_dir() const {
    return static_cast<Define::Dir>(flatbuffers::EndianScalar(move_dir_));
  }
};
FLATBUFFERS_STRUCT_END(PositionInfo, 16);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Stat FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_[3];

 public:
  Stat()
      : value_() {
  }
  Stat(flatbuffers::span<const int32_t, 3> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<int32_t, 3> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Stat, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Ability FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_[12];

 public:
  Ability()
      : value_() {
  }
  Ability(flatbuffers::span<const int32_t, 12> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<int32_t, 12> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Ability, 48);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Speed FLATBUFFERS_FINAL_CLASS {
 private:
  float value_[3];

 public:
  Speed()
      : value_() {
  }
  Speed(flatbuffers::span<const float, 3> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<float, 3> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Speed, 12);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) CharacterGear FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t index_[9];

 public:
  CharacterGear()
      : index_() {
  }
  CharacterGear(flatbuffers::span<const int32_t, 9> _index) {
    flatbuffers::CastToArray(index_).CopyFromSpan(_index);
  }
  const flatbuffers::Array<int32_t, 9> *index() const {
    return &flatbuffers::CastToArray(index_);
  }
};
FLATBUFFERS_STRUCT_END(CharacterGear, 36);

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(4) Money FLATBUFFERS_FINAL_CLASS {
 private:
  int32_t value_[2];

 public:
  Money()
      : value_() {
  }
  Money(flatbuffers::span<const int32_t, 2> _value) {
    flatbuffers::CastToArray(value_).CopyFromSpan(_value);
  }
  const flatbuffers::Array<int32_t, 2> *value() const {
    return &flatbuffers::CastToArray(value_);
  }
};
FLATBUFFERS_STRUCT_END(Money, 8);

struct ObjectInfoWithPosT : public flatbuffers::NativeTable {
  typedef ObjectInfoWithPos TableType;
  NativeInfo::ObjectInfo object_info{};
  NativeInfo::PositionInfo pos_info{};
};

struct ObjectInfoWithPos FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef ObjectInfoWithPosT NativeTableType;
  typedef ObjectInfoWithPosBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_OBJECT_INFO = 4,
    VT_POS_INFO = 6
  };
  const Info::ObjectInfo *object_info() const {
    return GetStruct<const Info::ObjectInfo *>(VT_OBJECT_INFO);
  }
  const Info::PositionInfo *pos_info() const {
    return GetStruct<const Info::PositionInfo *>(VT_POS_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Info::ObjectInfo>(verifier, VT_OBJECT_INFO) &&
           VerifyField<Info::PositionInfo>(verifier, VT_POS_INFO) &&
           verifier.EndTable();
  }
  ObjectInfoWithPosT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(ObjectInfoWithPosT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<ObjectInfoWithPos> Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoWithPosT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct ObjectInfoWithPosBuilder {
  typedef ObjectInfoWithPos Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_object_info(const Info::ObjectInfo *object_info) {
    fbb_.AddStruct(ObjectInfoWithPos::VT_OBJECT_INFO, object_info);
  }
  void add_pos_info(const Info::PositionInfo *pos_info) {
    fbb_.AddStruct(ObjectInfoWithPos::VT_POS_INFO, pos_info);
  }
  explicit ObjectInfoWithPosBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<ObjectInfoWithPos> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<ObjectInfoWithPos>(end);
    return o;
  }
};

inline flatbuffers::Offset<ObjectInfoWithPos> CreateObjectInfoWithPos(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Info::ObjectInfo *object_info = 0,
    const Info::PositionInfo *pos_info = 0) {
  ObjectInfoWithPosBuilder builder_(_fbb);
  builder_.add_pos_info(pos_info);
  builder_.add_object_info(object_info);
  return builder_.Finish();
}

flatbuffers::Offset<ObjectInfoWithPos> CreateObjectInfoWithPos(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoWithPosT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct StatWrapperT : public flatbuffers::NativeTable {
  typedef StatWrapper TableType;
  NativeInfo::Stat value{};
};

struct StatWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef StatWrapperT NativeTableType;
  typedef StatWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Info::Stat *value() const {
    return GetStruct<const Info::Stat *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Info::Stat>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  StatWrapperT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(StatWrapperT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<StatWrapper> Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct StatWrapperBuilder {
  typedef StatWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Info::Stat *value) {
    fbb_.AddStruct(StatWrapper::VT_VALUE, value);
  }
  explicit StatWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<StatWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<StatWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<StatWrapper> CreateStatWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Info::Stat *value = 0) {
  StatWrapperBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<StatWrapper> CreateStatWrapper(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct MoneyWrapperT : public flatbuffers::NativeTable {
  typedef MoneyWrapper TableType;
  NativeInfo::Money value{};
};

struct MoneyWrapper FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef MoneyWrapperT NativeTableType;
  typedef MoneyWrapperBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_VALUE = 4
  };
  const Info::Money *value() const {
    return GetStruct<const Info::Money *>(VT_VALUE);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Info::Money>(verifier, VT_VALUE) &&
           verifier.EndTable();
  }
  MoneyWrapperT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(MoneyWrapperT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<MoneyWrapper> Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct MoneyWrapperBuilder {
  typedef MoneyWrapper Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(const Info::Money *value) {
    fbb_.AddStruct(MoneyWrapper::VT_VALUE, value);
  }
  explicit MoneyWrapperBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<MoneyWrapper> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<MoneyWrapper>(end);
    return o;
  }
};

inline flatbuffers::Offset<MoneyWrapper> CreateMoneyWrapper(
    flatbuffers::FlatBufferBuilder &_fbb,
    const Info::Money *value = 0) {
  MoneyWrapperBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

flatbuffers::Offset<MoneyWrapper> CreateMoneyWrapper(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

struct CreatureInfoT : public flatbuffers::NativeTable {
  typedef CreatureInfo TableType;
  uint8_t level = 0;
  int64_t exp = 0;
  NativeInfo::Stat stat{};
  int32_t hp = 0;
  int32_t mp = 0;
  NativeInfo::Ability ability{};
  NativeInfo::Speed speed{};
};

struct CreatureInfo FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CreatureInfoT NativeTableType;
  typedef CreatureInfoBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_LEVEL = 4,
    VT_EXP = 6,
    VT_STAT = 8,
    VT_HP = 10,
    VT_MP = 12,
    VT_ABILITY = 14,
    VT_SPEED = 16
  };
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  int64_t exp() const {
    return GetField<int64_t>(VT_EXP, 0);
  }
  const Info::Stat *stat() const {
    return GetStruct<const Info::Stat *>(VT_STAT);
  }
  int32_t hp() const {
    return GetField<int32_t>(VT_HP, 0);
  }
  int32_t mp() const {
    return GetField<int32_t>(VT_MP, 0);
  }
  const Info::Ability *ability() const {
    return GetStruct<const Info::Ability *>(VT_ABILITY);
  }
  const Info::Speed *speed() const {
    return GetStruct<const Info::Speed *>(VT_SPEED);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           VerifyField<int64_t>(verifier, VT_EXP) &&
           VerifyField<Info::Stat>(verifier, VT_STAT) &&
           VerifyField<int32_t>(verifier, VT_HP) &&
           VerifyField<int32_t>(verifier, VT_MP) &&
           VerifyField<Info::Ability>(verifier, VT_ABILITY) &&
           VerifyField<Info::Speed>(verifier, VT_SPEED) &&
           verifier.EndTable();
  }
  CreatureInfoT *UnPack(const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  void UnPackTo(CreatureInfoT *_o, const flatbuffers::resolver_function_t *_resolver = nullptr) const;
  static flatbuffers::Offset<CreatureInfo> Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);
};

struct CreatureInfoBuilder {
  typedef CreatureInfo Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(CreatureInfo::VT_LEVEL, level, 0);
  }
  void add_exp(int64_t exp) {
    fbb_.AddElement<int64_t>(CreatureInfo::VT_EXP, exp, 0);
  }
  void add_stat(const Info::Stat *stat) {
    fbb_.AddStruct(CreatureInfo::VT_STAT, stat);
  }
  void add_hp(int32_t hp) {
    fbb_.AddElement<int32_t>(CreatureInfo::VT_HP, hp, 0);
  }
  void add_mp(int32_t mp) {
    fbb_.AddElement<int32_t>(CreatureInfo::VT_MP, mp, 0);
  }
  void add_ability(const Info::Ability *ability) {
    fbb_.AddStruct(CreatureInfo::VT_ABILITY, ability);
  }
  void add_speed(const Info::Speed *speed) {
    fbb_.AddStruct(CreatureInfo::VT_SPEED, speed);
  }
  explicit CreatureInfoBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CreatureInfo> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CreatureInfo>(end);
    return o;
  }
};

inline flatbuffers::Offset<CreatureInfo> CreateCreatureInfo(
    flatbuffers::FlatBufferBuilder &_fbb,
    uint8_t level = 0,
    int64_t exp = 0,
    const Info::Stat *stat = 0,
    int32_t hp = 0,
    int32_t mp = 0,
    const Info::Ability *ability = 0,
    const Info::Speed *speed = 0) {
  CreatureInfoBuilder builder_(_fbb);
  builder_.add_exp(exp);
  builder_.add_speed(speed);
  builder_.add_ability(ability);
  builder_.add_mp(mp);
  builder_.add_hp(hp);
  builder_.add_stat(stat);
  builder_.add_level(level);
  return builder_.Finish();
}

flatbuffers::Offset<CreatureInfo> CreateCreatureInfo(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher = nullptr);

inline ObjectInfoWithPosT *ObjectInfoWithPos::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<ObjectInfoWithPosT>(new ObjectInfoWithPosT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void ObjectInfoWithPos::UnPackTo(ObjectInfoWithPosT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = object_info(); if (_e) _o->object_info = flatbuffers::UnPackObjectInfo(*_e); }
  { auto _e = pos_info(); if (_e) _o->pos_info = flatbuffers::UnPackPositionInfo(*_e); }
}

inline flatbuffers::Offset<ObjectInfoWithPos> ObjectInfoWithPos::Pack(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoWithPosT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateObjectInfoWithPos(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<ObjectInfoWithPos> CreateObjectInfoWithPos(flatbuffers::FlatBufferBuilder &_fbb, const ObjectInfoWithPosT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const ObjectInfoWithPosT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _object_info = flatbuffers::PackObjectInfo(_o->object_info);
  auto _pos_info = flatbuffers::PackPositionInfo(_o->pos_info);
  return Info::CreateObjectInfoWithPos(
      _fbb,
      &_object_info,
      &_pos_info);
}

inline StatWrapperT *StatWrapper::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<StatWrapperT>(new StatWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void StatWrapper::UnPackTo(StatWrapperT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = flatbuffers::UnPackStat(*_e); }
}

inline flatbuffers::Offset<StatWrapper> StatWrapper::Pack(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateStatWrapper(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<StatWrapper> CreateStatWrapper(flatbuffers::FlatBufferBuilder &_fbb, const StatWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const StatWrapperT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = flatbuffers::PackStat(_o->value);
  return Info::CreateStatWrapper(
      _fbb,
      &_value);
}

inline MoneyWrapperT *MoneyWrapper::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<MoneyWrapperT>(new MoneyWrapperT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void MoneyWrapper::UnPackTo(MoneyWrapperT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = value(); if (_e) _o->value = flatbuffers::UnPackMoney(*_e); }
}

inline flatbuffers::Offset<MoneyWrapper> MoneyWrapper::Pack(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateMoneyWrapper(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<MoneyWrapper> CreateMoneyWrapper(flatbuffers::FlatBufferBuilder &_fbb, const MoneyWrapperT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const MoneyWrapperT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _value = flatbuffers::PackMoney(_o->value);
  return Info::CreateMoneyWrapper(
      _fbb,
      &_value);
}

inline CreatureInfoT *CreatureInfo::UnPack(const flatbuffers::resolver_function_t *_resolver) const {
  auto _o = std::unique_ptr<CreatureInfoT>(new CreatureInfoT());
  UnPackTo(_o.get(), _resolver);
  return _o.release();
}

inline void CreatureInfo::UnPackTo(CreatureInfoT *_o, const flatbuffers::resolver_function_t *_resolver) const {
  (void)_o;
  (void)_resolver;
  { auto _e = level(); _o->level = _e; }
  { auto _e = exp(); _o->exp = _e; }
  { auto _e = stat(); if (_e) _o->stat = flatbuffers::UnPackStat(*_e); }
  { auto _e = hp(); _o->hp = _e; }
  { auto _e = mp(); _o->mp = _e; }
  { auto _e = ability(); if (_e) _o->ability = flatbuffers::UnPackAbility(*_e); }
  { auto _e = speed(); if (_e) _o->speed = flatbuffers::UnPackSpeed(*_e); }
}

inline flatbuffers::Offset<CreatureInfo> CreatureInfo::Pack(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT* _o, const flatbuffers::rehasher_function_t *_rehasher) {
  return CreateCreatureInfo(_fbb, _o, _rehasher);
}

inline flatbuffers::Offset<CreatureInfo> CreateCreatureInfo(flatbuffers::FlatBufferBuilder &_fbb, const CreatureInfoT *_o, const flatbuffers::rehasher_function_t *_rehasher) {
  (void)_rehasher;
  (void)_o;
  struct _VectorArgs { flatbuffers::FlatBufferBuilder *__fbb; const CreatureInfoT* __o; const flatbuffers::rehasher_function_t *__rehasher; } _va = { &_fbb, _o, _rehasher}; (void)_va;
  auto _level = _o->level;
  auto _exp = _o->exp;
  auto _stat = flatbuffers::PackStat(_o->stat);
  auto _hp = _o->hp;
  auto _mp = _o->mp;
  auto _ability = flatbuffers::PackAbility(_o->ability);
  auto _speed = flatbuffers::PackSpeed(_o->speed);
  return Info::CreateCreatureInfo(
      _fbb,
      _level,
      _exp,
      &_stat,
      _hp,
      _mp,
      &_ability,
      &_speed);
}

}  // namespace Info

#endif  // FLATBUFFERS_GENERATED_INFOPROTOCOL_INFO_H_
