// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGIN_H_
#define FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGIN_H_

#include "flatbuffers/flatbuffers.h"

#include "define_protocol_generated.h"

namespace Login {

struct CS_LOGIN_REQ;
struct CS_LOGIN_REQBuilder;

struct CHARACTER_INFO;
struct CHARACTER_INFOBuilder;

struct SC_LOGIN_RES;
struct SC_LOGIN_RESBuilder;

struct SC_PING_REQ;
struct SC_PING_REQBuilder;

struct CS_PING_RES;
struct CS_PING_RESBuilder;

struct CS_LOGOUT_NOTI;
struct CS_LOGOUT_NOTIBuilder;

struct Root;
struct RootBuilder;

enum ErrorCode : int8_t {
  ErrorCode_SUCCESS = 0,
  ErrorCode_UNKNOWN = 1,
  ErrorCode_ALREADY_LOGINED = 2,
  ErrorCode_MIN = ErrorCode_SUCCESS,
  ErrorCode_MAX = ErrorCode_ALREADY_LOGINED
};

inline const ErrorCode (&EnumValuesErrorCode())[3] {
  static const ErrorCode values[] = {
    ErrorCode_SUCCESS,
    ErrorCode_UNKNOWN,
    ErrorCode_ALREADY_LOGINED
  };
  return values;
}

inline const char * const *EnumNamesErrorCode() {
  static const char * const names[4] = {
    "SUCCESS",
    "UNKNOWN",
    "ALREADY_LOGINED",
    nullptr
  };
  return names;
}

inline const char *EnumNameErrorCode(ErrorCode e) {
  if (flatbuffers::IsOutRange(e, ErrorCode_SUCCESS, ErrorCode_ALREADY_LOGINED)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesErrorCode()[index];
}

enum Packet : uint8_t {
  Packet_NONE = 0,
  Packet_CS_LOGIN_REQ = 1,
  Packet_SC_LOGIN_RES = 2,
  Packet_SC_PING_REQ = 3,
  Packet_CS_PING_RES = 4,
  Packet_CS_LOGOUT_NOTI = 5,
  Packet_MIN = Packet_NONE,
  Packet_MAX = Packet_CS_LOGOUT_NOTI
};

inline const Packet (&EnumValuesPacket())[6] {
  static const Packet values[] = {
    Packet_NONE,
    Packet_CS_LOGIN_REQ,
    Packet_SC_LOGIN_RES,
    Packet_SC_PING_REQ,
    Packet_CS_PING_RES,
    Packet_CS_LOGOUT_NOTI
  };
  return values;
}

inline const char * const *EnumNamesPacket() {
  static const char * const names[7] = {
    "NONE",
    "CS_LOGIN_REQ",
    "SC_LOGIN_RES",
    "SC_PING_REQ",
    "CS_PING_RES",
    "CS_LOGOUT_NOTI",
    nullptr
  };
  return names;
}

inline const char *EnumNamePacket(Packet e) {
  if (flatbuffers::IsOutRange(e, Packet_NONE, Packet_CS_LOGOUT_NOTI)) return "";
  const size_t index = static_cast<size_t>(e);
  return EnumNamesPacket()[index];
}

template<typename T> struct PacketTraits {
  static const Packet enum_value = Packet_NONE;
};

template<> struct PacketTraits<Login::CS_LOGIN_REQ> {
  static const Packet enum_value = Packet_CS_LOGIN_REQ;
};

template<> struct PacketTraits<Login::SC_LOGIN_RES> {
  static const Packet enum_value = Packet_SC_LOGIN_RES;
};

template<> struct PacketTraits<Login::SC_PING_REQ> {
  static const Packet enum_value = Packet_SC_PING_REQ;
};

template<> struct PacketTraits<Login::CS_PING_RES> {
  static const Packet enum_value = Packet_CS_PING_RES;
};

template<> struct PacketTraits<Login::CS_LOGOUT_NOTI> {
  static const Packet enum_value = Packet_CS_LOGOUT_NOTI;
};

bool VerifyPacket(flatbuffers::Verifier &verifier, const void *obj, Packet type);
bool VerifyPacketVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types);

struct CS_LOGIN_REQ FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CS_LOGIN_REQBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UID = 4,
    VT_TOKEN = 6
  };
  int64_t uid() const {
    return GetField<int64_t>(VT_UID, 0);
  }
  int32_t token() const {
    return GetField<int32_t>(VT_TOKEN, 0);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UID) &&
           VerifyField<int32_t>(verifier, VT_TOKEN) &&
           verifier.EndTable();
  }
};

struct CS_LOGIN_REQBuilder {
  typedef CS_LOGIN_REQ Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int64_t uid) {
    fbb_.AddElement<int64_t>(CS_LOGIN_REQ::VT_UID, uid, 0);
  }
  void add_token(int32_t token) {
    fbb_.AddElement<int32_t>(CS_LOGIN_REQ::VT_TOKEN, token, 0);
  }
  explicit CS_LOGIN_REQBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CS_LOGIN_REQ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CS_LOGIN_REQ>(end);
    return o;
  }
};

inline flatbuffers::Offset<CS_LOGIN_REQ> CreateCS_LOGIN_REQ(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t uid = 0,
    int32_t token = 0) {
  CS_LOGIN_REQBuilder builder_(_fbb);
  builder_.add_uid(uid);
  builder_.add_token(token);
  return builder_.Finish();
}

struct CHARACTER_INFO FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CHARACTER_INFOBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_UID = 4,
    VT_NAME = 6,
    VT_LEVEL = 8,
    VT_JOB = 10
  };
  int64_t uid() const {
    return GetField<int64_t>(VT_UID, 0);
  }
  const flatbuffers::String *name() const {
    return GetPointer<const flatbuffers::String *>(VT_NAME);
  }
  uint8_t level() const {
    return GetField<uint8_t>(VT_LEVEL, 0);
  }
  Define::Job job() const {
    return static_cast<Define::Job>(GetField<int8_t>(VT_JOB, 0));
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int64_t>(verifier, VT_UID) &&
           VerifyOffset(verifier, VT_NAME) &&
           verifier.VerifyString(name()) &&
           VerifyField<uint8_t>(verifier, VT_LEVEL) &&
           VerifyField<int8_t>(verifier, VT_JOB) &&
           verifier.EndTable();
  }
};

struct CHARACTER_INFOBuilder {
  typedef CHARACTER_INFO Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_uid(int64_t uid) {
    fbb_.AddElement<int64_t>(CHARACTER_INFO::VT_UID, uid, 0);
  }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) {
    fbb_.AddOffset(CHARACTER_INFO::VT_NAME, name);
  }
  void add_level(uint8_t level) {
    fbb_.AddElement<uint8_t>(CHARACTER_INFO::VT_LEVEL, level, 0);
  }
  void add_job(Define::Job job) {
    fbb_.AddElement<int8_t>(CHARACTER_INFO::VT_JOB, static_cast<int8_t>(job), 0);
  }
  explicit CHARACTER_INFOBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CHARACTER_INFO> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CHARACTER_INFO>(end);
    return o;
  }
};

inline flatbuffers::Offset<CHARACTER_INFO> CreateCHARACTER_INFO(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t uid = 0,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    uint8_t level = 0,
    Define::Job job = Define::Job_Warrior) {
  CHARACTER_INFOBuilder builder_(_fbb);
  builder_.add_uid(uid);
  builder_.add_name(name);
  builder_.add_job(job);
  builder_.add_level(level);
  return builder_.Finish();
}

inline flatbuffers::Offset<CHARACTER_INFO> CreateCHARACTER_INFODirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    int64_t uid = 0,
    const char *name = nullptr,
    uint8_t level = 0,
    Define::Job job = Define::Job_Warrior) {
  auto name__ = name ? _fbb.CreateString(name) : 0;
  return Login::CreateCHARACTER_INFO(
      _fbb,
      uid,
      name__,
      level,
      job);
}

struct SC_LOGIN_RES FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SC_LOGIN_RESBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_RESULT = 4,
    VT_MAX_SLOT_COUNT = 6,
    VT_EMPTY_SLOT_COUNT = 8,
    VT_CHARACTER_INFO = 10
  };
  Login::ErrorCode result() const {
    return static_cast<Login::ErrorCode>(GetField<int8_t>(VT_RESULT, 0));
  }
  uint8_t max_slot_count() const {
    return GetField<uint8_t>(VT_MAX_SLOT_COUNT, 0);
  }
  uint8_t empty_slot_count() const {
    return GetField<uint8_t>(VT_EMPTY_SLOT_COUNT, 0);
  }
  const flatbuffers::Vector<flatbuffers::Offset<Login::CHARACTER_INFO>> *character_info() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Login::CHARACTER_INFO>> *>(VT_CHARACTER_INFO);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_RESULT) &&
           VerifyField<uint8_t>(verifier, VT_MAX_SLOT_COUNT) &&
           VerifyField<uint8_t>(verifier, VT_EMPTY_SLOT_COUNT) &&
           VerifyOffset(verifier, VT_CHARACTER_INFO) &&
           verifier.VerifyVector(character_info()) &&
           verifier.VerifyVectorOfTables(character_info()) &&
           verifier.EndTable();
  }
};

struct SC_LOGIN_RESBuilder {
  typedef SC_LOGIN_RES Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_result(Login::ErrorCode result) {
    fbb_.AddElement<int8_t>(SC_LOGIN_RES::VT_RESULT, static_cast<int8_t>(result), 0);
  }
  void add_max_slot_count(uint8_t max_slot_count) {
    fbb_.AddElement<uint8_t>(SC_LOGIN_RES::VT_MAX_SLOT_COUNT, max_slot_count, 0);
  }
  void add_empty_slot_count(uint8_t empty_slot_count) {
    fbb_.AddElement<uint8_t>(SC_LOGIN_RES::VT_EMPTY_SLOT_COUNT, empty_slot_count, 0);
  }
  void add_character_info(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Login::CHARACTER_INFO>>> character_info) {
    fbb_.AddOffset(SC_LOGIN_RES::VT_CHARACTER_INFO, character_info);
  }
  explicit SC_LOGIN_RESBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SC_LOGIN_RES> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SC_LOGIN_RES>(end);
    return o;
  }
};

inline flatbuffers::Offset<SC_LOGIN_RES> CreateSC_LOGIN_RES(
    flatbuffers::FlatBufferBuilder &_fbb,
    Login::ErrorCode result = Login::ErrorCode_SUCCESS,
    uint8_t max_slot_count = 0,
    uint8_t empty_slot_count = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Login::CHARACTER_INFO>>> character_info = 0) {
  SC_LOGIN_RESBuilder builder_(_fbb);
  builder_.add_character_info(character_info);
  builder_.add_empty_slot_count(empty_slot_count);
  builder_.add_max_slot_count(max_slot_count);
  builder_.add_result(result);
  return builder_.Finish();
}

inline flatbuffers::Offset<SC_LOGIN_RES> CreateSC_LOGIN_RESDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    Login::ErrorCode result = Login::ErrorCode_SUCCESS,
    uint8_t max_slot_count = 0,
    uint8_t empty_slot_count = 0,
    const std::vector<flatbuffers::Offset<Login::CHARACTER_INFO>> *character_info = nullptr) {
  auto character_info__ = character_info ? _fbb.CreateVector<flatbuffers::Offset<Login::CHARACTER_INFO>>(*character_info) : 0;
  return Login::CreateSC_LOGIN_RES(
      _fbb,
      result,
      max_slot_count,
      empty_slot_count,
      character_info__);
}

struct SC_PING_REQ FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef SC_PING_REQBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct SC_PING_REQBuilder {
  typedef SC_PING_REQ Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit SC_PING_REQBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<SC_PING_REQ> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<SC_PING_REQ>(end);
    return o;
  }
};

inline flatbuffers::Offset<SC_PING_REQ> CreateSC_PING_REQ(
    flatbuffers::FlatBufferBuilder &_fbb) {
  SC_PING_REQBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CS_PING_RES FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CS_PING_RESBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CS_PING_RESBuilder {
  typedef CS_PING_RES Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CS_PING_RESBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CS_PING_RES> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CS_PING_RES>(end);
    return o;
  }
};

inline flatbuffers::Offset<CS_PING_RES> CreateCS_PING_RES(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CS_PING_RESBuilder builder_(_fbb);
  return builder_.Finish();
}

struct CS_LOGOUT_NOTI FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef CS_LOGOUT_NOTIBuilder Builder;
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct CS_LOGOUT_NOTIBuilder {
  typedef CS_LOGOUT_NOTI Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  explicit CS_LOGOUT_NOTIBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<CS_LOGOUT_NOTI> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<CS_LOGOUT_NOTI>(end);
    return o;
  }
};

inline flatbuffers::Offset<CS_LOGOUT_NOTI> CreateCS_LOGOUT_NOTI(
    flatbuffers::FlatBufferBuilder &_fbb) {
  CS_LOGOUT_NOTIBuilder builder_(_fbb);
  return builder_.Finish();
}

struct Root FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  typedef RootBuilder Builder;
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PACKET_TYPE = 4,
    VT_PACKET = 6
  };
  Login::Packet packet_type() const {
    return static_cast<Login::Packet>(GetField<uint8_t>(VT_PACKET_TYPE, 0));
  }
  const void *packet() const {
    return GetPointer<const void *>(VT_PACKET);
  }
  template<typename T> const T *packet_as() const;
  const Login::CS_LOGIN_REQ *packet_as_CS_LOGIN_REQ() const {
    return packet_type() == Login::Packet_CS_LOGIN_REQ ? static_cast<const Login::CS_LOGIN_REQ *>(packet()) : nullptr;
  }
  const Login::SC_LOGIN_RES *packet_as_SC_LOGIN_RES() const {
    return packet_type() == Login::Packet_SC_LOGIN_RES ? static_cast<const Login::SC_LOGIN_RES *>(packet()) : nullptr;
  }
  const Login::SC_PING_REQ *packet_as_SC_PING_REQ() const {
    return packet_type() == Login::Packet_SC_PING_REQ ? static_cast<const Login::SC_PING_REQ *>(packet()) : nullptr;
  }
  const Login::CS_PING_RES *packet_as_CS_PING_RES() const {
    return packet_type() == Login::Packet_CS_PING_RES ? static_cast<const Login::CS_PING_RES *>(packet()) : nullptr;
  }
  const Login::CS_LOGOUT_NOTI *packet_as_CS_LOGOUT_NOTI() const {
    return packet_type() == Login::Packet_CS_LOGOUT_NOTI ? static_cast<const Login::CS_LOGOUT_NOTI *>(packet()) : nullptr;
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<uint8_t>(verifier, VT_PACKET_TYPE) &&
           VerifyOffset(verifier, VT_PACKET) &&
           VerifyPacket(verifier, packet(), packet_type()) &&
           verifier.EndTable();
  }
};

template<> inline const Login::CS_LOGIN_REQ *Root::packet_as<Login::CS_LOGIN_REQ>() const {
  return packet_as_CS_LOGIN_REQ();
}

template<> inline const Login::SC_LOGIN_RES *Root::packet_as<Login::SC_LOGIN_RES>() const {
  return packet_as_SC_LOGIN_RES();
}

template<> inline const Login::SC_PING_REQ *Root::packet_as<Login::SC_PING_REQ>() const {
  return packet_as_SC_PING_REQ();
}

template<> inline const Login::CS_PING_RES *Root::packet_as<Login::CS_PING_RES>() const {
  return packet_as_CS_PING_RES();
}

template<> inline const Login::CS_LOGOUT_NOTI *Root::packet_as<Login::CS_LOGOUT_NOTI>() const {
  return packet_as_CS_LOGOUT_NOTI();
}

struct RootBuilder {
  typedef Root Table;
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_packet_type(Login::Packet packet_type) {
    fbb_.AddElement<uint8_t>(Root::VT_PACKET_TYPE, static_cast<uint8_t>(packet_type), 0);
  }
  void add_packet(flatbuffers::Offset<void> packet) {
    fbb_.AddOffset(Root::VT_PACKET, packet);
  }
  explicit RootBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  flatbuffers::Offset<Root> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<Root>(end);
    return o;
  }
};

inline flatbuffers::Offset<Root> CreateRoot(
    flatbuffers::FlatBufferBuilder &_fbb,
    Login::Packet packet_type = Login::Packet_NONE,
    flatbuffers::Offset<void> packet = 0) {
  RootBuilder builder_(_fbb);
  builder_.add_packet(packet);
  builder_.add_packet_type(packet_type);
  return builder_.Finish();
}

inline bool VerifyPacket(flatbuffers::Verifier &verifier, const void *obj, Packet type) {
  switch (type) {
    case Packet_NONE: {
      return true;
    }
    case Packet_CS_LOGIN_REQ: {
      auto ptr = reinterpret_cast<const Login::CS_LOGIN_REQ *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_SC_LOGIN_RES: {
      auto ptr = reinterpret_cast<const Login::SC_LOGIN_RES *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_SC_PING_REQ: {
      auto ptr = reinterpret_cast<const Login::SC_PING_REQ *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_CS_PING_RES: {
      auto ptr = reinterpret_cast<const Login::CS_PING_RES *>(obj);
      return verifier.VerifyTable(ptr);
    }
    case Packet_CS_LOGOUT_NOTI: {
      auto ptr = reinterpret_cast<const Login::CS_LOGOUT_NOTI *>(obj);
      return verifier.VerifyTable(ptr);
    }
    default: return true;
  }
}

inline bool VerifyPacketVector(flatbuffers::Verifier &verifier, const flatbuffers::Vector<flatbuffers::Offset<void>> *values, const flatbuffers::Vector<uint8_t> *types) {
  if (!values || !types) return !values && !types;
  if (values->size() != types->size()) return false;
  for (flatbuffers::uoffset_t i = 0; i < values->size(); ++i) {
    if (!VerifyPacket(
        verifier,  values->Get(i), types->GetEnum<Packet>(i))) {
      return false;
    }
  }
  return true;
}

inline const Login::Root *GetRoot(const void *buf) {
  return flatbuffers::GetRoot<Login::Root>(buf);
}

inline const Login::Root *GetSizePrefixedRoot(const void *buf) {
  return flatbuffers::GetSizePrefixedRoot<Login::Root>(buf);
}

inline bool VerifyRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<Login::Root>(nullptr);
}

inline bool VerifySizePrefixedRootBuffer(
    flatbuffers::Verifier &verifier) {
  return verifier.VerifySizePrefixedBuffer<Login::Root>(nullptr);
}

inline void FinishRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Login::Root> root) {
  fbb.Finish(root);
}

inline void FinishSizePrefixedRootBuffer(
    flatbuffers::FlatBufferBuilder &fbb,
    flatbuffers::Offset<Login::Root> root) {
  fbb.FinishSizePrefixed(root);
}

}  // namespace Login

#endif  // FLATBUFFERS_GENERATED_LOGINPROTOCOL_LOGIN_H_
